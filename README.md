GeneratePresetImpl:
Сортировка типов юнитов по убыванию эффективности производится с помощью сортировки Timsort, обладающей сложностью O(n*log(n)), где n - количество типов юнитов в unitList.

Создание и заполнение списка доступных координат имеет сложность O(COMPUTER_WIDTH * COMPUTER_HEIGHT), что в нашем - O(61), то есть O(1).
Перемешивание коллекции с помощью Collection.shuffle() имеет сложность O(k), где k - количество элементов в списке. То есть также O(1).

Добавление юнитов в армию имеет сложность O(n), т.к. максимальное количество юнитов одного типа у нас зафиксировано константой и равно 11. Проверка условий итерации, клонирование юнита, взятие очередной пары координат (и так далее) выполняются за константу и не участвуют в данной сложности.

Итоговая сложность: O(n*log(n)) + O(1) + O(n) = O(n*log(n)), где n - количество типов юнитов в unitList.

SimulateBattleImpl:
Получение юнитов с isAlive = true.
Метод filterAliveUnits() проходит по каждому юниту армии и имеет сложность O(m), где m - количество юнитов в армии.

Создание очередей.
Добавление всех юнитов в очередь имеет сложность O(k*log(k)), где k - текущий размер списка юнитов.

Очередь атаки.
Метод moveAndAttack() для каждой очереди повторяется, пока она не опустеет, где каждое извлечение из очереди имеет сложность O(log(k)).

Один полный раунд.
Обработка всех юнитов (две армии) ведет к O(n*log(n)) операций для каждой армии. То есть 2*O(n*log(n)) или все то же O(n*log(n)).

Итоговая сложность:
Если рассматривать вариант, пока одна из армий не будет полностью уничтожена, то потребуется O(n) атак.
Общая сложность за все раунды может быть оценена как O(n^2*log(n)).

SuitableForAttackUnitsFinderImpl:
Итоговая сложность:
Мы обрабатываем все строки,  учитывая, что количество рядов фиксировано и равно трем, мы можем объявить сложность как O(n)

UnitTargetPathFinderImpl:
Инициализация. На этапе инициализации создаются и инициализируются массивы distances, visited и predecessors. Общая сложность будет составлять O(WIDTH * HEIGHT).

Формирование координат занятых позиций.
Вычисление множества координат, занятых юнитами позиций выполняется за O(n), где n - количество юнитов в existingUnitList.

Основной цикл алгоритма (алгоритм Дейкстры).
Для обработки узлов в порядке увеличения их стоимости используется очередь с приоритетом (которая реализуется на базе кучи) и позволяет выполнять операции добавления и извлечения за O(log(k)), где k - текущее количество элементов в очереди.

Для каждой клетки сетки в худшем случае добавляется связь со всеми ее соседями (до четырех) и каждый узел помещается в очередь хотя бы один раз. Следовательно, получение из очереди и добавление всех соседей выполняются за O(WIDTH*HEIGHT*log(WIDTH*HEIGHT).

Формирование пути.
После завершения обработки все узлы находятся в матрице predecessors и плгоритм восстанавливает путь от целевой точки, двигаясь назад к начальной. Это имеет сложность O(l), где l - длина пути, но эта длина ограничена количеством узлов, то есть O(WIDTH + HEIGHT).

Итоговая сложность:
-Инициализация массивов: O(WIDTH*HEIGHT)
-Перебор всех клеток и работа с очередью: O(WIDTH*HEIGHT*log(WIDTH*HEIGHT))

Таким образом, итоговой сложностью можно считать O((WIDTH*HEIGHT)*log(WIDTH*HEIGHT)).
